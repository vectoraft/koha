.\" -*- mode: troff; coding: utf-8 -*-
.\" Automatically generated by Pod::Man 5.01 (Pod::Simple 3.43)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" \*(C` and \*(C' are quotes in nroff, nothing in troff, for use with C<>.
.ie n \{\
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is >0, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{\
.    if \nF \{\
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{\
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\" ========================================================================
.\"
.IX Title "AppConfig::State 3pm"
.TH AppConfig::State 3pm 2015-03-01 "perl v5.38.2" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH NAME
AppConfig::State \- application configuration state
.SH SYNOPSIS
.IX Header "SYNOPSIS"
.Vb 1
\&    use AppConfig::State;
\&
\&    my $state = AppConfig::State\->new(\e%cfg);
\&
\&    $state\->define("foo");            # very simple variable definition
\&    $state\->define("bar", \e%varcfg);  # variable specific configuration
\&    $state\->define("foo|bar=i@");     # compact format
\&
\&    $state\->set("foo", 123);          # trivial set/get examples
\&    $state\->get("foo");      
\&
\&    $state\->foo();                    # shortcut variable access 
\&    $state\->foo(456);                 # shortcut variable update
.Ve
.SH OVERVIEW
.IX Header "OVERVIEW"
AppConfig::State is a Perl5 module to handle global configuration variables
for perl programs.  It maintains the state of any number of variables,
handling default values, aliasing, validation, update callbacks and 
option arguments for use by other AppConfig::* modules.
.PP
AppConfig::State is distributed as part of the AppConfig bundle.
.SH DESCRIPTION
.IX Header "DESCRIPTION"
.SS "USING THE AppConfig::State MODULE"
.IX Subsection "USING THE AppConfig::State MODULE"
To import and use the AppConfig::State module the following line should 
appear in your Perl script:
.PP
.Vb 1
\&     use AppConfig::State;
.Ve
.PP
The AppConfig::State module is loaded automatically by the \fBnew()\fR
constructor of the AppConfig module.
.PP
AppConfig::State is implemented using object-oriented methods.  A 
new AppConfig::State object is created and initialised using the 
\&\fBnew()\fR method.  This returns a reference to a new AppConfig::State 
object.
.PP
.Vb 1
\&    my $state = AppConfig::State\->new();
.Ve
.PP
This will create a reference to a new AppConfig::State with all 
configuration options set to their default values.  You can initialise 
the object by passing a reference to a hash array containing 
configuration options:
.PP
.Vb 4
\&    $state = AppConfig::State\->new( {
\&        CASE      => 1,
\&        ERROR     => \e&my_error,
\&    } );
.Ve
.PP
The \fBnew()\fR constructor of the AppConfig module automatically passes all 
parameters to the AppConfig::State \fBnew()\fR constructor.  Thus, any global 
configuration values and variable definitions for AppConfig::State are 
also applicable to AppConfig.
.PP
The following configuration options may be specified.
.IP CASE 4
.IX Item "CASE"
Determines if the variable names are treated case sensitively.  Any non-zero
value makes case significant when naming variables.  By default, CASE is set
to 0 and thus "Variable", "VARIABLE" and "VaRiAbLe" are all treated as 
"variable".
.IP CREATE 4
.IX Item "CREATE"
By default, CREATE is turned off meaning that all variables accessed via
\&\fBset()\fR (which includes access via shortcut such as 
\&\f(CW\*(C`$state\->variable($value)\*(C'\fR which delegates to \fBset()\fR) must previously 
have been defined via \fBdefine()\fR.  When CREATE is set to 1, calling 
set($variable, \f(CW$value\fR) on a variable that doesn't exist will cause it 
to be created automatically.
.Sp
When CREATE is set to any other non-zero value, it is assumed to be a
regular expression pattern.  If the variable name matches the regex, the
variable is created.  This can be used to specify configuration file 
blocks in which variables should be created, for example:
.Sp
.Vb 3
\&    $state = AppConfig::State\->new( {
\&        CREATE => \*(Aq^define_\*(Aq,
\&    } );
.Ve
.Sp
In a config file:
.Sp
.Vb 2
\&    [define]
\&    name = fred           # define_name gets created automatically
\&
\&    [other]
\&    name = john           # other_name doesn\*(Aqt \- warning raised
.Ve
.Sp
Note that a regex pattern specified in CREATE is applied to the real 
variable name rather than any alias by which the variables may be 
accessed.
.IP PEDANTIC 4
.IX Item "PEDANTIC"
The PEDANTIC option determines what action the configuration file 
(AppConfig::File) or argument parser (AppConfig::Args) should take 
on encountering a warning condition (typically caused when trying to set an
undeclared variable).  If PEDANTIC is set to any true value, the parsing
methods will immediately return a value of 0 on encountering such a
condition.  If PEDANTIC is not set, the method will continue to parse the
remainder of the current file(s) or arguments, returning 0 when complete.
.Sp
If no warnings or errors are encountered, the method returns 1.
.Sp
In the case of a system error (e.g. unable to open a file), the method
returns undef immediately, regardless of the PEDANTIC option.
.IP ERROR 4
.IX Item "ERROR"
Specifies a user-defined error handling routine.  When the handler is 
called, a format string is passed as the first parameter, followed by 
any additional values, as per printf(3C).
.IP DEBUG 4
.IX Item "DEBUG"
Turns debugging on or off when set to 1 or 0 accordingly.  Debugging may 
also be activated by calling \fB_debug()\fR as an object method 
(\f(CW\*(C`$state\->_debug(1)\*(C'\fR) or as a package function 
(\f(CWAppConfig::State::_debug(1)\fR), passing in a true/false value to 
set the debugging state accordingly.  The package variable 
\&\f(CW$AppConfig::State::DEBUG\fR can also be set directly.
.Sp
The \fB_debug()\fR method returns the current debug value.  If a new value 
is passed in, the internal value is updated, but the previous value is 
returned.
.Sp
Note that any AppConfig::File or App::Config::Args objects that are 
instantiated with a reference to an App::State will inherit the 
DEBUG (and also PEDANTIC) values of the state at that time.  Subsequent
changes to the AppConfig::State debug value will not affect them.
.IP GLOBAL 4
.IX Item "GLOBAL"
The GLOBAL option allows default values to be set for the DEFAULT, ARGCOUNT, 
EXPAND, VALIDATE and ACTION options for any subsequently defined variables.
.Sp
.Vb 7
\&    $state = AppConfig::State\->new({
\&        GLOBAL => {
\&            DEFAULT  => \*(Aq<undef>\*(Aq,     # default value for new vars
\&            ARGCOUNT => 1,             # vars expect an argument
\&            ACTION   => \e&my_set_var,  # callback when vars get set
\&        }
\&    });
.Ve
.Sp
Any attributes specified explicitly when a variable is defined will
override any GLOBAL values.
.Sp
See "DEFINING VARIABLES" below which describes these options in detail.
.SS "DEFINING VARIABLES"
.IX Subsection "DEFINING VARIABLES"
The \f(CWdefine()\fR function is used to pre-declare a variable and specify 
its configuration.
.PP
.Vb 1
\&    $state\->define("foo");
.Ve
.PP
In the simple example above, a new variable called "foo" is defined.  A 
reference to a hash array may also be passed to specify configuration 
information for the variable:
.PP
.Vb 4
\&    $state\->define("foo", {
\&            DEFAULT   => 99,
\&            ALIAS     => \*(Aqmetavar1\*(Aq,
\&        });
.Ve
.PP
Any variable-wide GLOBAL values passed to the \fBnew()\fR constructor in the 
configuration hash will also be applied.  Values explicitly specified 
in a variable's \fBdefine()\fR configuration will override the respective GLOBAL 
values.
.PP
The following configuration options may be specified
.IP DEFAULT 4
.IX Item "DEFAULT"
The DEFAULT value is used to initialise the variable.
.Sp
.Vb 3
\&    $state\->define("drink", {
\&            DEFAULT => \*(Aqcoffee\*(Aq,
\&        });
\&
\&    print $state\->drink();        # prints "coffee"
.Ve
.IP ALIAS 4
.IX Item "ALIAS"
The ALIAS option allows a number of alternative names to be specified for 
this variable.  A single alias should be specified as a string.  Multiple 
aliases can be specified as a reference to an array of alternatives or as 
a string of names separated by vertical bars, '|'.  e.g.:
.Sp
.Vb 4
\&    # either
\&    $state\->define("name", {
\&            ALIAS  => \*(Aqperson\*(Aq,
\&        });
\&
\&    # or
\&    $state\->define("name", {
\&            ALIAS => [ \*(Aqperson\*(Aq, \*(Aquser\*(Aq, \*(Aquid\*(Aq ],
\&        });
\&
\&    # or
\&    $state\->define("name", {
\&            ALIAS => \*(Aqperson|user|uid\*(Aq,
\&        });
\&
\&    $state\->user(\*(Aqabw\*(Aq);     # equivalent to $state\->name(\*(Aqabw\*(Aq);
.Ve
.IP ARGCOUNT 4
.IX Item "ARGCOUNT"
The ARGCOUNT option specifies the number of arguments that should be 
supplied for this variable.  By default, no additional arguments are 
expected for variables (ARGCOUNT_NONE).
.Sp
The ARGCOUNT_* constants can be imported from the AppConfig module:
.Sp
.Vb 1
\&    use AppConfig \*(Aq:argcount\*(Aq;
\&
\&    $state\->define(\*(Aqfoo\*(Aq, { ARGCOUNT => ARGCOUNT_ONE });
.Ve
.Sp
or can be accessed directly from the AppConfig package:
.Sp
.Vb 1
\&    use AppConfig;
\&
\&    $state\->define(\*(Aqfoo\*(Aq, { ARGCOUNT => AppConfig::ARGCOUNT_ONE });
.Ve
.Sp
The following values for ARGCOUNT may be specified.
.RS 4
.IP "ARGCOUNT_NONE (0)" 4
.IX Item "ARGCOUNT_NONE (0)"
Indicates that no additional arguments are expected.  If the variable is
identified in a confirguration file or in the command line arguments, it
is set to a value of 1 regardless of whatever arguments follow it.
.IP "ARGCOUNT_ONE (1)" 4
.IX Item "ARGCOUNT_ONE (1)"
Indicates that the variable expects a single argument to be provided.
The variable value will be overwritten with a new value each time it 
is encountered.
.IP "ARGCOUNT_LIST (2)" 4
.IX Item "ARGCOUNT_LIST (2)"
Indicates that the variable expects multiple arguments.  The variable 
value will be appended to the list of previous values each time it is
encountered.
.IP "ARGCOUNT_HASH (3)" 4
.IX Item "ARGCOUNT_HASH (3)"
Indicates that the variable expects multiple arguments and that each
argument is of the form "key=value".  The argument will be split into 
a key/value pair and inserted into the hash of values each time it 
is encountered.
.RE
.RS 4
.RE
.IP ARGS 4
.IX Item "ARGS"
The ARGS option can also be used to specify advanced command line options 
for use with AppConfig::Getopt, which itself delegates to Getopt::Long.  
See those two modules for more information on the format and meaning of
these options.
.Sp
.Vb 3
\&    $state\->define("name", {
\&            ARGS => "=i@",
\&        });
.Ve
.IP EXPAND 4
.IX Item "EXPAND"
The EXPAND option specifies how the AppConfig::File processor should 
expand embedded variables in the configuration file values it reads.
By default, EXPAND is turned off (EXPAND_NONE) and no expansion is made.
.Sp
The EXPAND_* constants can be imported from the AppConfig module:
.Sp
.Vb 1
\&    use AppConfig \*(Aq:expand\*(Aq;
\&
\&    $state\->define(\*(Aqfoo\*(Aq, { EXPAND => EXPAND_VAR });
.Ve
.Sp
or can be accessed directly from the AppConfig package:
.Sp
.Vb 1
\&    use AppConfig;
\&
\&    $state\->define(\*(Aqfoo\*(Aq, { EXPAND => AppConfig::EXPAND_VAR });
.Ve
.Sp
The following values for EXPAND may be specified.  Multiple values should
be combined with vertical bars , '|', e.g. \f(CW\*(C`EXPAND_UID | EXPAND_VAR\*(C'\fR).
.RS 4
.IP EXPAND_NONE 4
.IX Item "EXPAND_NONE"
Indicates that no variable expansion should be attempted.
.IP EXPAND_VAR 4
.IX Item "EXPAND_VAR"
Indicates that variables embedded as \f(CW$var\fR or $(var) should be expanded
to the values of the relevant AppConfig::State variables.
.IP EXPAND_UID 4
.IX Item "EXPAND_UID"
Indicates that '~' or '~uid' patterns in the string should be 
expanded to the current users ($<), or specified user's home directory.
In the first case, \f(CW\*(C`~\*(C'\fR is expanded to the value of the \f(CW\*(C`HOME\*(C'\fR
environment variable.  In the second case, the \f(CWgetpwnam()\fR method
is used if it is available on your system (which it isn't on Win32).
.IP EXPAND_ENV 4
.IX Item "EXPAND_ENV"
Inidicates that variables embedded as ${var} should be expanded to the 
value of the relevant environment variable.
.IP EXPAND_ALL 4
.IX Item "EXPAND_ALL"
Equivalent to \f(CW\*(C`EXPAND_VARS | EXPAND_UIDS | EXPAND_ENVS\*(C'\fR).
.IP EXPAND_WARN 4
.IX Item "EXPAND_WARN"
Indicates that embedded variables that are not defined should raise a
warning.  If PEDANTIC is set, this will cause the \fBread()\fR method to return 0
immediately.
.RE
.RS 4
.RE
.IP VALIDATE 4
.IX Item "VALIDATE"
Each variable may have a sub-routine or regular expression defined which 
is used to validate the intended value for a variable before it is set.
.Sp
If VALIDATE is defined as a regular expression, it is applied to the
value and deemed valid if the pattern matches.  In this case, the
variable is then set to the new value.  A warning message is generated
if the pattern match fails.
.Sp
VALIDATE may also be defined as a reference to a sub-routine which takes
as its arguments the name of the variable and its intended value.  The 
sub-routine should return 1 or 0 to indicate that the value is valid
or invalid, respectively.  An invalid value will cause a warning error
message to be generated.
.Sp
If the GLOBAL VALIDATE variable is set (see GLOBAL in DESCRIPTION 
above) then this value will be used as the default VALIDATE for each 
variable unless otherwise specified.
.Sp
.Vb 3
\&    $state\->define("age", {
\&            VALIDATE => \*(Aq\ed+\*(Aq,
\&        });
\&
\&    $state\->define("pin", {
\&            VALIDATE => \e&check_pin,
\&        });
.Ve
.IP ACTION 4
.IX Item "ACTION"
The ACTION option allows a sub-routine to be bound to a variable as a
callback that is executed whenever the variable is set.  The ACTION is
passed a reference to the AppConfig::State object, the name of the
variable and the value of the variable.
.Sp
The ACTION routine may be used, for example, to post-process variable
data, update the value of some other dependant variable, generate a
warning message, etc.
.Sp
Example:
.Sp
.Vb 1
\&    $state\->define("foo", { ACTION => \e&my_notify });
\&
\&    sub my_notify {
\&        my $state = shift;
\&        my $var   = shift;
\&        my $val   = shift;
\&
\&        print "$variable set to $value";
\&    }
\&
\&    $state\->foo(42);        # prints "foo set to 42"
.Ve
.Sp
Be aware that calling \f(CW\*(C`$state\->set()\*(C'\fR to update the same variable
from within the ACTION function will cause a recursive loop as the
ACTION function is repeatedly called.
.SS "DEFINING VARIABLES USING THE COMPACT FORMAT"
.IX Subsection "DEFINING VARIABLES USING THE COMPACT FORMAT"
Variables may be defined in a compact format which allows any ALIAS and
ARGS values to be specified as part of the variable name.  This is designed
to mimic the behaviour of Johan Vromans' Getopt::Long module.
.PP
Aliases for a variable should be specified after the variable name, 
separated by vertical bars, '|'.  Any ARGS parameter should be appended 
after the variable name(s) and/or aliases.
.PP
The following examples are equivalent:
.PP
.Vb 4
\&    $state\->define("foo", { 
\&            ALIAS => [ \*(Aqbar\*(Aq, \*(Aqbaz\*(Aq ],
\&            ARGS  => \*(Aq=i\*(Aq,
\&        });
\&
\&    $state\->define("foo|bar|baz=i");
.Ve
.SS "READING AND MODIFYING VARIABLE VALUES"
.IX Subsection "READING AND MODIFYING VARIABLE VALUES"
AppConfig::State defines two methods to manipulate variable values:
.PP
.Vb 2
\&    set($variable, $value);
\&    get($variable);
.Ve
.PP
Both functions take the variable name as the first parameter and
\&\f(CWset()\fR takes an additional parameter which is the new value for the
variable.  \f(CWset()\fR returns 1 or 0 to indicate successful or
unsuccessful update of the variable value.  If there is an ACTION
routine associated with the named variable, the value returned will be
passed back from \f(CWset()\fR.  The \f(CWget()\fR function returns the current
value of the variable.
.PP
Once defined, variables may be accessed directly as object methods where
the method name is the same as the variable name.  i.e.
.PP
.Vb 1
\&    $state\->set("verbose", 1);
.Ve
.PP
is equivalent to
.PP
.Vb 1
\&    $state\->verbose(1);
.Ve
.PP
Without parameters, the current value of the variable is returned.  If
a parameter is specified, the variable is set to that value and the 
result of the \fBset()\fR operation is returned.
.PP
.Vb 1
\&    $state\->age(29);        # sets \*(Aqage\*(Aq to 29, returns 1 (ok)
.Ve
.SS VARLIST
.IX Subsection "VARLIST"
The \fBvarlist()\fR method can be used to extract a number of variables into
a hash array.  The first parameter should be a regular expression
used for matching against the variable names.
.PP
.Vb 1
\&    my %vars = $state\->varlist("^file");   # all "file*" variables
.Ve
.PP
A second parameter may be specified (any true value) to indicate that
the part of the variable name matching the regex should be removed
when copied to the target hash.
.PP
.Vb 2
\&    $state\->file_name("/tmp/file");
\&    $state\->file_path("/foo:/bar:/baz");
\&
\&    my %vars = $state\->varlist("^file_", 1);
\&
\&    # %vars:
\&    #    name => /tmp/file
\&    #    path => "/foo:/bar:/baz"
.Ve
.SS "INTERNAL METHODS"
.IX Subsection "INTERNAL METHODS"
The interal (private) methods of the AppConfig::State class are listed 
below.
.PP
They aren't intended for regular use and potential users should consider
the fact that nothing about the internal implementation is guaranteed to
remain the same.  Having said that, the AppConfig::State class is
intended to co-exist and work with a number of other modules and these
are considered "friend" classes.  These methods are provided, in part,
as services to them.  With this acknowledged co-operation in mind, it is
safe to assume some stability in this core interface.
.PP
The \fB_varname()\fR method can be used to determine the real name of a variable 
from an alias:
.PP
.Vb 1
\&    $varname\->_varname($alias);
.Ve
.PP
Note that all methods that take a variable name, including those listed
below, can accept an alias and automatically resolve it to the correct 
variable name.  There is no need to call \fB_varname()\fR explicitly to do 
alias expansion.  The \fB_varname()\fR method will fold all variables names
to lower case unless CASE sensititvity is set.
.PP
The \fB_exists()\fR method can be used to check if a variable has been
defined:
.PP
.Vb 1
\&    $state\->_exists($varname);
.Ve
.PP
The \fB_default()\fR method can be used to reset a variable to its default value:
.PP
.Vb 1
\&    $state\->_default($varname);
.Ve
.PP
The \fB_expand()\fR method can be used to determine the EXPAND value for a 
variable:
.PP
.Vb 1
\&    print "$varname EXPAND: ", $state\->_expand($varname), "\en";
.Ve
.PP
The \fB_argcount()\fR method returns the value of the ARGCOUNT attribute for a 
variable:
.PP
.Vb 1
\&    print "$varname ARGCOUNT: ", $state\->_argcount($varname), "\en";
.Ve
.PP
The \fB_validate()\fR method can be used to determine if a new value for a variable
meets any validation criteria specified for it.  The variable name and 
intended value should be passed in.  The methods returns a true/false value
depending on whether or not the validation succeeded:
.PP
.Vb 1
\&    print "OK\en" if $state\->_validate($varname, $value);
.Ve
.PP
The \fB_pedantic()\fR method can be called to determine the current value of the
PEDANTIC option.
.PP
.Vb 1
\&    print "pedantic mode is ", $state\->_pedantic() ? "on" ; "off", "\en";
.Ve
.PP
The \fB_debug()\fR method can be used to turn debugging on or off (pass 1 or 0
as a parameter).  It can also be used to check the debug state,
returning the current internal value of \f(CW$AppConfig::State::DEBUG\fR.  If a
new debug value is provided, the debug state is updated and the previous
state is returned.
.PP
.Vb 1
\&    $state\->_debug(1);               # debug on, returns previous value
.Ve
.PP
The _dump_var($varname) and \fB_dump()\fR methods may also be called for
debugging purposes.
.PP
.Vb 2
\&    $state\->_dump_var($varname);    # show variable state
\&    $state\->_dump();                # show internal state and all vars
.Ve
.SH AUTHOR
.IX Header "AUTHOR"
Andy Wardley, <abw@wardley.org>
.SH COPYRIGHT
.IX Header "COPYRIGHT"
Copyright (C) 1997\-2007 Andy Wardley.  All Rights Reserved.
.PP
Copyright (C) 1997,1998 Canon Research Centre Europe Ltd.
.PP
This module is free software; you can redistribute it and/or modify it 
under the same terms as Perl itself.
.SH "SEE ALSO"
.IX Header "SEE ALSO"
AppConfig, AppConfig::File, AppConfig::Args, AppConfig::Getopt
